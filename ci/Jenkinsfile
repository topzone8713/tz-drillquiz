pipeline {
    agent {
        kubernetes {
            label 'docker'
            defaultContainer 'docker'
        }
    }
    
    environment {
        GIT_BRANCH = "${env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main'}"
        GIT_COMMITTER_EMAIL = "doohee323@gmail.com"

        BUILD_NUMBER = "${env.BUILD_NUMBER ?: 'latest'}"
        DOCKER_NAME = "drillquiz"
        FRONT_DOCKER_NAME = "drillquiz-frontend"
        APP_NAME = "drillquiz"
        DEPLOYMENT_NAME = 'drillquiz'
        NAMESPACE = "${(env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') == 'main' || (env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') == 'qa' ? 'devops' : 'devops-dev'}"
        NODE_ENV = "development"
        K8S_FILE = "k8s.yaml"

        KUBECTL = "kubectl -n ${NAMESPACE}"
        // Try both possible credential IDs - Jenkins credential ID might be 'my-ubuntu.config' or 'kubeconfig-jenkins'
        KUBECONFIG_CREDENTIALS_ID = 'kubeconfig-jenkins'

        GIT_CREDENTIAL = 'github-token'

        REGISTRY = 'doohee323'
        DOCKERHUB_CREDENTIALS_ID = 'DOCKERHUB_CREDENTIALS_ID'

        // Domain configuration
        BASE_DOMAIN = "${BASE_DOMAIN ?: 'drillquiz.com'}"
        
        GIT_USERNAME = 'doohee323'
        GIT_REPO_NAME = 'tz-argocd-repo'
        
        // Credentials and ArgoCD configuration are loaded in 'Load Credentials' stage to handle optional credentials gracefully
        
        // Security scan control variables
        // QA branch: Full security scanning
        // Main branch (Production): Critical security only
        // Other branches: Disabled for performance
        
        // Critical security for production (Main branch)
        CONTAINER_SCAN_YN = 'false' // "${(env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') in ['qa', 'main'] ? 'false' : 'false'}"
        SBOM_YN = 'false' // "${(env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') in ['qa', 'main'] ? 'false' : 'false'}"
        IMAGE_SIGNING_YN = 'false' // "${(env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') in ['qa', 'main'] ? 'false' : 'false'}"
        
        // Full security scanning (QA only)
        SAST_YN = 'false' // "${(env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') == 'qa' ? 'true' : 'false'}"
        SCA_YN = 'false' // "${(env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') == 'qa' ? 'true' : 'false'}"
        IAC_SCAN_YN = 'false' // "${(env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') == 'qa' ? 'true' : 'false'}"
        DAST_SCAN_YN = 'false' // "${(env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') == 'qa' ? 'true' : 'false'}"
        PROVENANCE_YN = 'false' // "${(env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') == 'qa' ? 'true' : 'false'}"
        SECURITY_GATE_YN = 'false' // "${(env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') == 'qa' ? 'true' : 'false'}"
        
        // DAST scan configuration
        SERVICE_URL = "${(env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') == 'qa' ? 'http://drillquiz-qa.devops.svc.cluster.local:80' : 'http://drillquiz.devops.svc.cluster.local:80'}"
    }

    stages {
        stage('Load Credentials') {
            steps {
                script {
                    // Load credentials using withCredentials to ensure proper resolution
                    // Required credentials
                    try {
                        withCredentials([string(credentialsId: 'GITHUB_TOKEN', variable: 'GIT_TOKEN')]) {
                            env.GIT_TOKEN = env.GIT_TOKEN
                        }
                    } catch (Exception e) {
                        echo "âš ï¸  GITHUB_TOKEN credential not found, using empty string"
                        env.GIT_TOKEN = ''
                    }

                    try {
                        withCredentials([string(credentialsId: 'DOCKER_PASSWORD', variable: 'DOCKER_PASSWORD')]) {
                            env.DOCKER_PASSWORD = env.DOCKER_PASSWORD
                        }
                    } catch (Exception e) {
                        echo "âš ï¸  DOCKER_PASSWORD credential not found, using empty string"
                        env.DOCKER_PASSWORD = ''
                    }

                    try {
                        withCredentials([string(credentialsId: 'POSTGRES_PASSWORD', variable: 'POSTGRES_PASSWORD')]) {
                            env.POSTGRES_PASSWORD = env.POSTGRES_PASSWORD
                        }
                    } catch (Exception e) {
                        echo "âš ï¸  POSTGRES_PASSWORD credential not found, using empty string"
                        env.POSTGRES_PASSWORD = ''
                    }

                    // Optional credentials - set to empty if not found
                    try {
                        withCredentials([string(credentialsId: 'MINIO_ACCESS_KEY', variable: 'MINIO_ACCESS_KEY')]) {
                            env.MINIO_ACCESS_KEY = env.MINIO_ACCESS_KEY
                        }
                    } catch (Exception e) {
                        echo "âš ï¸  MINIO_ACCESS_KEY credential not found, using empty string"
                        env.MINIO_ACCESS_KEY = ''
                    }

                    try {
                        withCredentials([string(credentialsId: 'MINIO_SECRET_KEY', variable: 'MINIO_SECRET_KEY')]) {
                            env.MINIO_SECRET_KEY = env.MINIO_SECRET_KEY
                        }
                    } catch (Exception e) {
                        echo "âš ï¸  MINIO_SECRET_KEY credential not found, using empty string"
                        env.MINIO_SECRET_KEY = ''
                    }

                    // ArgoCD credentials
                    try {
                        withCredentials([string(credentialsId: 'ARGOCD_PASSWORD', variable: 'ARGOCD_PASSWORD')]) {
                            env.ARGOCD_PASSWORD = env.ARGOCD_PASSWORD
                        }
                    } catch (Exception e) {
                        echo "âš ï¸  ARGOCD_PASSWORD credential not found, using empty string"
                        env.ARGOCD_PASSWORD = ''
                    }

                    // Application API keys
                    try {
                        withCredentials([string(credentialsId: 'GOOGLE_OAUTH_CLIENT_SECRET', variable: 'GOOGLE_OAUTH_CLIENT_SECRET')]) {
                            env.GOOGLE_OAUTH_CLIENT_SECRET = env.GOOGLE_OAUTH_CLIENT_SECRET
                        }
                    } catch (Exception e) {
                        echo "âš ï¸  GOOGLE_OAUTH_CLIENT_SECRET credential not found, using empty string"
                        env.GOOGLE_OAUTH_CLIENT_SECRET = ''
                    }

                    try {
                        withCredentials([string(credentialsId: 'OPENAI_API_KEY', variable: 'OPENAI_API_KEY')]) {
                            env.OPENAI_API_KEY = env.OPENAI_API_KEY
                        }
                    } catch (Exception e) {
                        echo "âš ï¸  OPENAI_API_KEY credential not found, using empty string"
                        env.OPENAI_API_KEY = ''
                    }

                    try {
                        withCredentials([string(credentialsId: 'GEMINI_API_KEY', variable: 'GEMINI_API_KEY')]) {
                            env.GEMINI_API_KEY = env.GEMINI_API_KEY
                        }
                    } catch (Exception e) {
                        echo "âš ï¸  GEMINI_API_KEY credential not found, using empty string"
                        env.GEMINI_API_KEY = ''
                    }

                    // Email SMTP credentials
                    try {
                        withCredentials([string(credentialsId: 'SMTP_USERNAME', variable: 'SMTP_USERNAME')]) {
                            env.SMTP_USERNAME = env.SMTP_USERNAME
                        }
                    } catch (Exception e) {
                        echo "âš ï¸  SMTP_USERNAME credential not found, using empty string"
                        env.SMTP_USERNAME = ''
                    }

                    try {
                        withCredentials([string(credentialsId: 'SMTP_PASSWORD', variable: 'SMTP_PASSWORD')]) {
                            env.SMTP_PASSWORD = env.SMTP_PASSWORD
                        }
                    } catch (Exception e) {
                        echo "âš ï¸  SMTP_PASSWORD credential not found, using empty string"
                        env.SMTP_PASSWORD = ''
                    }

                    // MinIO configuration
                    env.MINIO_ENDPOINT = 'http://minio.devops.svc.cluster.local:9000'
                    env.MINIO_BUCKET_NAME = 'drillquiz'

                    // ArgoCD configuration
                    env.ARGOCD_ID = "tz-admin"
                    env.ARGOCD_SERVER = 'argocd.drillquiz.com'
                    env.ARGOCD_REPO_URL = 'https://github.com/doohee323/tz-argocd-repo.git'
                    // ë¸Œëœì¹˜ì— ë”°ë¼ ArgoCD í™œì„±í™” ì—¬ë¶€ ê²°ì •
                    env.ARGOCD_ENABLED = "${(env.BRANCH_NAME ?: env.GIT_BRANCH ?: env.CHANGE_BRANCH ?: 'main').replaceAll('^origin/', '') == 'qa' ? 'true' : 'false'}"
                }
            }
        }

        stage('Checkout') {
            steps {
                container('docker') {
                    script {
                        checkout scm
                    }
                }
            }
        }

        stage('Pre-Build Security Scan') {
            when {
                anyOf {
                    environment name: 'SAST_YN', value: 'false'
                    environment name: 'SCA_YN', value: 'false'
                    environment name: 'IAC_SCAN_YN', value: 'false'
                    environment name: 'SBOM_YN', value: 'false'
                }
            }
            steps {
                container('docker') {
                    script {
                        try {
                            echo "ğŸ” Starting pre-build security scan (Static Analysis)..."
                            sh '''
                                export PATH=$PATH:.:
                                export MINIO_ACCESS_KEY=${MINIO_ACCESS_KEY}
                                export MINIO_SECRET_KEY=${MINIO_SECRET_KEY}
                                export MINIO_ENDPOINT=${MINIO_ENDPOINT}
                                export MINIO_BUCKET_NAME=${MINIO_BUCKET_NAME}
                                export BUILD_NUMBER=${BUILD_NUMBER}
                                export REGISTRY=${REGISTRY}
                                export APP_NAME=${APP_NAME}
                                export DOCKER_NAME=${DOCKER_NAME}
                                export FRONT_DOCKER_NAME=${FRONT_DOCKER_NAME}
                                export SAST_YN=${SAST_YN}
                                export SCA_YN=${SCA_YN}
                                export IAC_SCAN_YN=${IAC_SCAN_YN}
                                export SBOM_YN=${SBOM_YN}

                                if [ -f "ci/security-scan.sh" ]; then
                                    chmod +x ci/security-scan.sh
                                    ./ci/security-scan.sh pre-build
                                else
                                    echo "âš ï¸  ci/security-scan.sh not found. Skipping pre-build security scan."
                                fi
                            '''
                        } catch (err) {
                            echo "Pre-build security scan failed: ${err}"
                            echo "âš ï¸  Pre-build security scan failed but continuing pipeline."
                        }
                    }
                }
            }
//             post {
//                 always {
//                     archiveArtifacts artifacts: '*.sarif,sbom-*.spdx.json,sbom-*.txt', fingerprint: true, allowEmptyArchive: true
//                     publishHTML([
//                         allowMissing: false,
//                         alwaysLinkToLastBuild: true,
//                         keepAll: true,
//                         reportDir: '.',
//                         reportFiles: '*.html',
//                         reportName: 'Pre-Build Security Report'
//                     ])
//                 }
//             }
        }

        stage('Security Gate (Pre-Build)') {
            when {
                allOf {
                    environment name: 'SECURITY_GATE_YN', value: 'false'
                    anyOf {
                        environment name: 'SAST_YN', value: 'false'
                        environment name: 'SCA_YN', value: 'false'
                        environment name: 'IAC_SCAN_YN', value: 'false'
                    }
                }
            }
            steps {
                container('docker') {
                    sh '''
                        if [ -f "ci/security-gate.sh" ]; then
                            echo "ğŸ”’ Running Pre-Build Security Gate..."
                            chmod +x ci/security-gate.sh
                            echo "ğŸ” Checking generated SARIF files:"
                            ls -la *.sarif 2>/dev/null || echo "  No SARIF files found."

                            # Run Security Gate with pre-build SARIF files
                            ./ci/security-gate.sh \
                                semgrep.sarif \
                                semgrep-python.sarif \
                                semgrep-frontend.sarif \
                                semgrep-dependencies.sarif \
                                sca-python.sarif \
                                sca-node.sarif \
                                sca-requirements.sarif \
                                sca-package.sarif \
                                sca-os.sarif \
                                checkov-k8s.sarif \
                                checkov-docker.sarif \
                                kube-linter.sarif
                        else
                            echo "âš ï¸  ci/security-gate.sh not found. Skipping Pre-Build Security Gate."
                        fi
                    '''
                }
            }
        }

        stage('Build Frontend') {
            steps {
                container('docker') {
                    script {
                        try {
                            // Docker Hub ì¸ì¦ì„ í†µí•´ rate limit ë¬¸ì œ í•´ê²°
                            withDockerRegistry(credentialsId: "${DOCKERHUB_CREDENTIALS_ID}", url: '') {
                                echo "ğŸš€ Starting frontend build..."
                                sh '''
                                    export PATH=$PATH:.:
                                    echo "ğŸ”§ Installing bash..."
                                    if command -v apk >/dev/null 2>&1; then
                                        echo "ğŸ“¦ Using Alpine Linux package manager (apk)..."
                                        apk add --no-cache bash
                                    elif command -v apt-get >/dev/null 2>&1; then
                                        echo "ğŸ“¦ Using Debian/Ubuntu package manager (apt-get)..."
                                        apt-get update && apt-get install -y bash
                                    elif command -v yum >/dev/null 2>&1; then
                                        echo "ğŸ“¦ Using CentOS/RHEL package manager (yum)..."
                                        yum install -y bash
                                    else
                                        echo "âŒ No supported package manager found"
                                        exit 1
                                    fi
                                    echo "âœ… Bash installation completed"
                                    echo "ğŸ” Checking ci/k8s.sh file..."
                                    ls -la ci/k8s.sh || echo "âŒ ci/k8s.sh not found"
                                    if [ -f "ci/k8s.sh" ]; then
                                        echo "âœ… ci/k8s.sh found, setting permissions..."
                                        chmod +x ci/k8s.sh
                                        echo "ğŸš€ Executing ci/k8s.sh..."
                                        export BASE_DOMAIN=${BASE_DOMAIN}
                                        export APP_NAME=${APP_NAME}
                                        ./ci/k8s.sh ${BUILD_NUMBER} ${GIT_BRANCH} ${NAMESPACE} build-frontend
                                    else
                                        echo "âŒ ci/k8s.sh file not found in workspace"
                                        echo "ğŸ“ Current directory contents:"
                                        ls -la
                                        echo "ğŸ“ ci/ directory contents:"
                                        ls -la ci/ || echo "ci/ directory not found"
                                        exit 1
                                    fi
                                '''
                            }
                        } catch (err) {
                            echo "Frontend build failed: ${err}"
                            error("Stopping pipeline due to frontend build failure..")
                        }
                    }
                }
            }
        }
        
        stage('Build & Push Backend Image') {
            steps {
                container('docker') {
                    script {
                        try {
                            withDockerRegistry(credentialsId: "${DOCKERHUB_CREDENTIALS_ID}", url: '') {
                                def image = "${REGISTRY}/${DOCKER_NAME}:${BUILD_NUMBER}"
                                sh "cp -Rf Dockerfile.backend Dockerfile"
                                sh "docker build -t ${image} ."

                                echo "Pushing image: ${image}"
                                sh "docker push ${image}"
                            }
                        } catch (err) {
                            echo "Docker push failed: ${err}"
                            error("Stopping pipeline due to push failure.")
                        }
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                container('kubectl') {
                    script {
                        try {
                            // KUBECONFIG is required for Kubernetes deployment
                            // Use credential ID directly (not via environment variable to avoid resolution issues)
                            try {
                                withCredentials([file(credentialsId: 'kubeconfig-jenkins', variable: 'KUBECONFIG')]) {
                                    echo "âœ… Using KUBECONFIG credential: kubeconfig-jenkins"
                                    sh '''
                                        export PATH=$PATH:.:
                                        echo "ğŸ”§ Installing bash..."
                                        if command -v apk >/dev/null 2>&1; then
                                            echo "ğŸ“¦ Using Alpine Linux package manager (apk)..."
                                            apk add --no-cache bash
                                        elif command -v apt-get >/dev/null 2>&1; then
                                            echo "ğŸ“¦ Using Debian/Ubuntu package manager (apt-get)..."
                                            apt-get update && apt-get install -y bash
                                        elif command -v yum >/dev/null 2>&1; then
                                            echo "ğŸ“¦ Using CentOS/RHEL package manager (yum)..."
                                            yum install -y bash
                                        else
                                            echo "âŒ No supported package manager found"
                                            exit 1
                                        fi
                                        echo "âœ… Bash installation completed"
                                        echo "ğŸ” Checking ci/k8s.sh file..."
                                        ls -la ci/k8s.sh || echo "âŒ ci/k8s.sh not found"
                                        if [ -f "ci/k8s.sh" ]; then
                                            echo "âœ… ci/k8s.sh found, setting permissions..."
                                            chmod +x ci/k8s.sh
                                            echo "ğŸš€ Starting Kubernetes deployment..."
                                            echo "  BUILD_NUMBER: ${BUILD_NUMBER}"
                                            echo "  GIT_BRANCH: ${GIT_BRANCH}"
                                            echo "  NAMESPACE: ${NAMESPACE}"
                                            echo "  ARGOCD_ENABLED: ${ARGOCD_ENABLED}"
                                            echo "  ARGOCD_SERVER: ${ARGOCD_SERVER}"
                                            echo "  ARGOCD_REPO_URL: ${ARGOCD_REPO_URL}"
                                            echo "  BASE_DOMAIN: ${BASE_DOMAIN}"
                                            echo "  APP_NAME: ${APP_NAME}"
                                            export BASE_DOMAIN=${BASE_DOMAIN}
                                            export APP_NAME=${APP_NAME}
                                            export POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
                                            export SMTP_USERNAME=${SMTP_USERNAME}
                                            export SMTP_PASSWORD=${SMTP_PASSWORD}
                                            echo "  POSTGRES_PASSWORD length: ${#POSTGRES_PASSWORD}"
                                            ./ci/k8s.sh ${BUILD_NUMBER} ${GIT_BRANCH} ${NAMESPACE} deploy
                                        else
                                            echo "âŒ ci/k8s.sh file not found in workspace"
                                            echo "ğŸ“ Current directory contents:"
                                            ls -la
                                            echo "ğŸ“ ci/ directory contents:"
                                            ls -la ci/ || echo "ci/ directory not found"
                                            exit 1
                                        fi
                                    '''
                                }
                            } catch (Exception e) {
                                error("âŒ KUBECONFIG credential 'kubeconfig-jenkins' is required but not found in Jenkins. Please configure the credential in Jenkins Credentials Store. Error: ${e.getMessage()}")
                            }
                        } catch (err) {
                            echo "kubectl failed: ${err}"
                            error("Stopping pipeline due to kubectl failure.")
                        }
                    }
                }
            }
        }

        stage('Run Use Case Tests') {
            when {
                allOf {
                    environment name: 'USECASE_YN', value: 'true'
                    anyOf {
                        branch 'main'
                        branch 'qa'
                        branch 'develop'
                    }
                }
            }
            steps {
                container('docker') {
                    script {
                        try {
                            echo "ğŸ¯ Starting use case tests..."
                            sh '''
                                export PATH=$PATH:.:
                                echo "ğŸ”§ Installing bash..."
                                if command -v apk >/dev/null 2>&1; then
                                    echo "ğŸ“¦ Using Alpine Linux package manager (apk)..."
                                    apk add --no-cache bash
                                elif command -v apt-get >/dev/null 2>&1; then
                                    echo "ğŸ“¦ Using Debian/Ubuntu package manager (apt-get)..."
                                    apt-get update && apt-get install -y bash
                                elif command -v yum >/dev/null 2>&1; then
                                    echo "ğŸ“¦ Using CentOS/RHEL package manager (yum)..."
                                    yum install -y bash
                                else
                                    echo "âŒ No supported package manager found"
                                    exit 1
                                fi
                                echo "âœ… Bash installation completed"
                                export MINIO_ACCESS_KEY=${MINIO_ACCESS_KEY}
                                export MINIO_SECRET_KEY=${MINIO_SECRET_KEY}
                                export MINIO_ENDPOINT=${MINIO_ENDPOINT}
                                export MINIO_BUCKET_NAME=${MINIO_BUCKET_NAME}
                                export POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
                                echo "ğŸ” Checking ci/k8s.sh file..."
                                ls -la ci/k8s.sh || echo "âŒ ci/k8s.sh not found"
                                if [ -f "ci/k8s.sh" ]; then
                                    echo "âœ… ci/k8s.sh found, setting permissions..."
                                    chmod +x ci/k8s.sh
                                    echo "ğŸš€ Starting use case tests..."
                                    echo "  BUILD_NUMBER: ${BUILD_NUMBER}"
                                    echo "  GIT_BRANCH: ${GIT_BRANCH}"
                                    echo "  NAMESPACE: ${NAMESPACE}"
                                    ./ci/k8s.sh ${BUILD_NUMBER} ${GIT_BRANCH} ${NAMESPACE} usecase-test all
                                else
                                    echo "âŒ ci/k8s.sh file not found in workspace"
                                    echo "ğŸ“ Current directory contents:"
                                    ls -la
                                    echo "ğŸ“ ci/ directory contents:"
                                    ls -la ci/ || echo "ci/ directory not found"
                                    exit 1
                                fi
                            '''
                        } catch (err) {
                            echo "Use case tests failed: ${err}"
                            echo "âš ï¸  Use case tests failed but continuing pipeline."
                        }
                    }
                }
            }
        }

        stage('Post-Build Security Scan') {
            when {
                anyOf {
                    environment name: 'CONTAINER_SCAN_YN', value: 'false'
                    environment name: 'DAST_SCAN_YN', value: 'false'
                    environment name: 'IMAGE_SIGNING_YN', value: 'false'
                }
            }
            steps {
                container('docker') {
                    script {
                        try {
                            echo "ğŸ” Starting post-build security scan (Dynamic Analysis)..."
                            sh '''
                                export PATH=$PATH:.:
                                export MINIO_ACCESS_KEY=${MINIO_ACCESS_KEY}
                                export MINIO_SECRET_KEY=${MINIO_SECRET_KEY}
                                export MINIO_ENDPOINT=${MINIO_ENDPOINT}
                                export MINIO_BUCKET_NAME=${MINIO_BUCKET_NAME}
                                export BUILD_NUMBER=${BUILD_NUMBER}
                                export SERVICE_URL=${SERVICE_URL}
                                export REGISTRY=${REGISTRY}
                                export APP_NAME=${APP_NAME}
                                export DOCKER_NAME=${DOCKER_NAME}
                                export FRONT_DOCKER_NAME=${FRONT_DOCKER_NAME}
                                export CONTAINER_SCAN_YN=${CONTAINER_SCAN_YN}
                                export DAST_SCAN_YN=${DAST_SCAN_YN}
                                export IMAGE_SIGNING_YN=${IMAGE_SIGNING_YN}
                                if [ -f "ci/security-scan.sh" ]; then
                                    chmod +x ci/security-scan.sh
                                    ./ci/security-scan.sh post-build
                                else
                                    echo "âš ï¸  ci/security-scan.sh not found. Skipping post-build security scan."
                                fi
                            '''
                        } catch (err) {
                            echo "Post-build security scan failed: ${err}"
                            echo "âš ï¸  Post-build security scan failed but continuing pipeline."
                        }
                    }
                }
            }
//             post {
//                 always {
//                     archiveArtifacts artifacts: '*.sarif,security-scan-summary.txt,zap-baseline-report.html,nikto.json,sbom-*.spdx.json,sbom-*.txt,cosign.pub', fingerprint: true, allowEmptyArchive: true
//                     publishHTML([
//                         allowMissing: false,
//                         alwaysLinkToLastBuild: true,
//                         keepAll: true,
//                         reportDir: '.',
//                         reportFiles: '*.html',
//                         reportName: 'Post-Build Security Report'
//                     ])
//                 }
//             }
        }

//         stage('Security Gate (Post-Deploy)') {
//             when {
//                 allOf {
//                     environment name: 'SECURITY_GATE_YN', value: 'false'
//                     anyOf {
//                         environment name: 'CONTAINER_SCAN_YN', value: 'false'
//                         environment name: 'DAST_SCAN_YN', value: 'false'
//                     }
//                 }
//             }
//             steps {
//                 container('docker') {
//                     sh '''
//                         echo "ğŸ”’ Running Post-Deploy Security Gate..."
//                         chmod +x ci/security-gate.sh
//                         echo "ğŸ” Checking generated SARIF files:"
//                         ls -la *.sarif 2>/dev/null || echo "  No SARIF files found."
//
//                         # Run Security Gate with post-build SARIF files
//                         ./ci/security-gate.sh \
//                             image-backend.sarif \
//                             image-frontend.sarif \
//                             image-config.sarif \
//                             zap-baseline.sarif \
//                             nikto.sarif
//                     '''
//                 }
//             }
//         }
    }

    post {
        always {
            // Archive security scan results only if they exist
            script {
                def sarifFiles = sh(script: "find . -name '*.sarif' -type f", returnStdout: true).trim()
                def sbomFiles = sh(script: "find . -name 'sbom-*' -type f", returnStdout: true).trim()
                def signingFiles = sh(script: "find . -name 'cosign.pub' -type f", returnStdout: true).trim()

                if (sarifFiles || sbomFiles || signingFiles) {
                    archiveArtifacts artifacts: '*.sarif,sbom-*.spdx.json,sbom-*.txt,cosign.pub', fingerprint: true, allowEmptyArchive: true
                } else {
                    echo "No security scan files found to archive"
                }
            }

            // ì´ì „ í”„ë¡œì íŠ¸ì™€ ë™ì¼í•œ ë°©ì‹: always ë¸”ë¡ì—ì„œ script ë°–ì—ì„œ emailext í˜¸ì¶œ
            script {
                // ì»¤ë°‹í•œ ì‚¬ëŒì˜ ì´ë©”ì¼ ì£¼ì†Œ ê°€ì ¸ì˜¤ê¸°
                def commitAuthorEmail = ''
                try {
                    // Pull Requestì¸ ê²½ìš°
                    if (env.CHANGE_AUTHOR_EMAIL) {
                        commitAuthorEmail = env.CHANGE_AUTHOR_EMAIL
                        echo "ğŸ“§ Pull Request ì‘ì„±ì ì´ë©”ì¼: ${commitAuthorEmail}"
                    } else {
                        // ì¼ë°˜ ì»¤ë°‹ì¸ ê²½ìš°
                        // git logë¡œ ì‹¤ì œ ì»¤ë°‹ì˜ author email ê°€ì ¸ì˜¤ê¸° (Jenkins í™˜ê²½ ë³€ìˆ˜ëŠ” ì‹ ë¢°í•˜ì§€ ì•ŠìŒ)
                        // fortinet.com ì´ë©”ì¼ì€ í•„í„°ë§í•˜ì—¬ ê¸°ë³¸ ì´ë©”ì¼ ì‚¬ìš©
                        def defaultEmail = env.DEFAULT_COMMIT_EMAIL ?: 'doohee323@gmail.com'

                        container('docker') {
                            def gitEmail = sh(
                                script: 'git log -1 --pretty=format:%ae',
                                returnStdout: true
                            ).trim()
                            echo "ğŸ“§ Git logì—ì„œ ê°€ì ¸ì˜¨ ì´ë©”ì¼: ${gitEmail}"

                            // fortinet.com ì´ë©”ì¼ì€ ì œì™¸í•˜ê³  ê¸°ë³¸ ì´ë©”ì¼ ì‚¬ìš©
                            if (gitEmail && gitEmail.contains('@') && !gitEmail.contains('fortinet.com')) {
                                commitAuthorEmail = gitEmail
                            } else {
                                commitAuthorEmail = defaultEmail
                                echo "ğŸ“§ fortinet.com ì´ë©”ì¼ í•„í„°ë§, ê¸°ë³¸ ì´ë©”ì¼ ì‚¬ìš©: ${commitAuthorEmail}"
                            }
                        }
                    }

                    // ì´ë©”ì¼ ì£¼ì†Œê°€ ìœ íš¨í•œ ê²½ìš°ì—ë§Œ ì „ì†¡
                    if (commitAuthorEmail && commitAuthorEmail.contains('@')) {
                        def buildUrl = env.BUILD_URL ?: 'N/A'
                        def jobName = env.JOB_NAME ?: 'tz-todo-demo Build'
                        def buildNumber = env.BUILD_NUMBER ?: 'N/A'
                        def branchName = env.BRANCH_NAME ?: env.GIT_BRANCH ?: 'N/A'
                        def buildResult = currentBuild.currentResult ?: 'UNKNOWN'

                        // ì´ë©”ì¼ ì œëª©ê³¼ ë³¸ë¬¸ ì„¤ì •
                        def emailSubject = buildResult == 'SUCCESS' ?
                            "âœ… [tz-todo-demo] ë¹Œë“œ ì„±ê³µ - ${jobName} #${buildNumber}" :
                            "âŒ [tz-todo-demo] ë¹Œë“œ ì‹¤íŒ¨ - ${jobName} #${buildNumber}"

                        def emailBody = buildResult == 'SUCCESS' ? """
                            <h2>ë¹Œë“œê°€ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤</h2>
                            <p><strong>í”„ë¡œì íŠ¸:</strong> ${jobName}</p>
                            <p><strong>ë¹Œë“œ ë²ˆí˜¸:</strong> #${buildNumber}</p>
                            <p><strong>ë¸Œëœì¹˜:</strong> ${branchName}</p>
                            <p><strong>ë¹Œë“œ URL:</strong> <a href="${buildUrl}">${buildUrl}</a></p>
                            <p><strong>ì»¤ë°‹:</strong> ${env.GIT_COMMIT ?: 'N/A'}</p>
                            <hr>
                            <p>â€» Full build log is attached.</p>
                            <p>ì´ ì´ë©”ì¼ì€ ìë™ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
                        """ : """
                            <h2>ë¹Œë“œê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤</h2>
                            <p><strong>í”„ë¡œì íŠ¸:</strong> ${jobName}</p>
                            <p><strong>ë¹Œë“œ ë²ˆí˜¸:</strong> #${buildNumber}</p>
                            <p><strong>ë¸Œëœì¹˜:</strong> ${branchName}</p>
                            <p><strong>ë¹Œë“œ URL:</strong> <a href="${buildUrl}">${buildUrl}</a></p>
                            <p><strong>ì»¤ë°‹:</strong> ${env.GIT_COMMIT ?: 'N/A'}</p>
                            <hr>
                            <p>â€» Full build log is attached. ë¡œê·¸ë¥¼ í™•ì¸í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•´ì£¼ì„¸ìš”.</p>
                            <p>ì´ ì´ë©”ì¼ì€ ìë™ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
                        """

                        // í™˜ê²½ ë³€ìˆ˜ì— ì €ì¥ (script ë¸”ë¡ ë°–ì—ì„œ ì‚¬ìš©í•˜ê¸° ìœ„í•´)
                        env.COMMIT_AUTHOR_EMAIL = commitAuthorEmail
                        env.EMAIL_SUBJECT = emailSubject
                        env.EMAIL_BODY = emailBody
                        env.SEND_EMAIL = 'true'
                    } else {
                        env.SEND_EMAIL = 'false'
                    }
                } catch (Exception e) {
                    echo "âš ï¸ ì´ë©”ì¼ ì£¼ì†Œ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: ${e.getMessage()}"
                    env.SEND_EMAIL = 'false'
                }
            }

            // script ë¸”ë¡ ë°–ì—ì„œ emailext í˜¸ì¶œ (ì´ì „ í”„ë¡œì íŠ¸ì™€ ë™ì¼í•œ ë°©ì‹)
            // attachLog: trueê°€ ì‘ë™í•˜ë ¤ë©´ script ë¸”ë¡ ë°–ì—ì„œ í˜¸ì¶œí•´ì•¼ í•¨
            script {
                if (env.SEND_EMAIL == 'true' && env.COMMIT_AUTHOR_EMAIL && env.COMMIT_AUTHOR_EMAIL.contains('@')) {
                    // FROM_EMAILì´ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ NAVER SMTP ì¸ì¦ ê³„ì •ê³¼ ì¼ì¹˜í•˜ëŠ” ì£¼ì†Œ ì‚¬ìš©
                    // NAVER SMTPëŠ” ë°œì‹ ì ì£¼ì†Œê°€ ì¸ì¦ëœ ì‚¬ìš©ìì™€ ì¼ì¹˜í•´ì•¼ í•¨
                    def fromEmail = env.FROM_EMAIL ?: 'doohee323@naver.com'

                    try {
                        // ë¬¸ìì—´ ë³´ê°„ ê²½ê³ ë¥¼ í”¼í•˜ê¸° ìœ„í•´ ë³€ìˆ˜ë¡œ ë¶„ë¦¬
                        def emailSubject = env.EMAIL_SUBJECT
                        def emailBody = env.EMAIL_BODY
                        def emailTo = env.COMMIT_AUTHOR_EMAIL

                        emailext(
                            subject: emailSubject,
                            body: emailBody,
                            to: emailTo,
                            from: fromEmail,
                            mimeType: 'text/html',
                            attachLog: true,
                            compressLog: true,
                            replyTo: fromEmail
                        )
                        def resultIcon = currentBuild.currentResult == 'SUCCESS' ? 'âœ…' : 'âŒ'
                        echo "${resultIcon} ì´ë©”ì¼ ì „ì†¡ ì™„ë£Œ: ${emailTo} (from: ${fromEmail})"
                    } catch (Exception e) {
                        echo "âš ï¸ ì´ë©”ì¼ ì „ì†¡ ì‹¤íŒ¨: ${e.getMessage()}"
                        echo "ğŸ“§ ì´ë©”ì¼ ì£¼ì†Œ: ${env.COMMIT_AUTHOR_EMAIL}"
                        echo "ğŸ“§ ë°œì‹ ì: ${fromEmail}"
                        // ì´ë©”ì¼ ì „ì†¡ ì‹¤íŒ¨í•´ë„ ë¹Œë“œëŠ” ê³„ì† ì§„í–‰
                    }
                }
            }
        }
        success {
            echo "âœ… Pipeline completed successfully"
        }
        failure {
            echo "âŒ Pipeline failed"
        }
    }
}

